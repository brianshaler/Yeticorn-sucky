// Generated by CoffeeScript 1.4.0
(function() {
  var Crystal, Crystals, cardHeight, cardTemplate, cardWidth, template,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  template = require('views/templates/crystals');

  cardTemplate = require('views/templates/card');

  Crystal = require('models/crystal_card');

  cardWidth = 142;

  cardHeight = 223;

  module.exports = Crystals = (function(_super) {

    __extends(Crystals, _super);

    function Crystals() {
      this.render = __bind(this.render, this);

      this.onStackClick = __bind(this.onStackClick, this);
      return Crystals.__super__.constructor.apply(this, arguments);
    }

    Crystals.prototype.template = template;

    Crystals.prototype.cardTemplate = cardTemplate;

    Crystals.prototype.cardWidth = cardWidth;

    Crystals.prototype.cardHeight = cardHeight;

    Crystals.prototype.defaults = {
      player: '',
      crystals: [[], [], [], [], [], []],
      lastRender: [-1, 0, 0, 0, 0, 0],
      left: 0,
      right: 0,
      top: 0,
      width: 1,
      height: 1
    };

    Crystals.prototype.initialize = function() {
      var crystal, i, prop, val, _i, _ref, _ref1, _results;
      this.div = $('<div>');
      this.width = 1;
      this.height = 1;
      _ref = this.attributes;
      for (prop in _ref) {
        val = _ref[prop];
        this[prop] = val;
      }
      this.crystals[0].push(new Crystal());
      this.crystals[0].push(new Crystal());
      this.crystals[0].push(new Crystal());
      this.crystals[2].push(new Crystal());
      this.crystals[2].push(new Crystal());
      this.crystals[2].push(new Crystal());
      this.crystals[3].push(new Crystal());
      this.crystals[3].push(new Crystal());
      this.crystals[3].push(new Crystal());
      this.crystals[3].push(new Crystal());
      this.crystals[3].push(new Crystal());
      this.crystals[4].push(new Crystal());
      this.crystals[4].push(new Crystal());
      this.crystals[4].push(new Crystal());
      this.crystals[5].push(new Crystal());
      _results = [];
      for (i = _i = 0, _ref1 = this.crystals.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _results.push((function() {
          var _j, _len, _ref2, _results1;
          _ref2 = this.crystals[i];
          _results1 = [];
          for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
            crystal = _ref2[_j];
            _results1.push(crystal.energy = i);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Crystals.prototype.update = function(prop, val) {
      var props;
      if (typeof prop === 'object') {
        props = prop;
      } else {
        props = {};
        props[prop] = val;
      }
      for (prop in props) {
        val = props[prop];
        if ((prop != null) && this.attributes.hasOwnProperty(prop)) {
          this.attributes[prop] = val;
        }
        this[prop] = val;
      }
      return this.render();
    };

    Crystals.prototype.incrementAll = function() {
      var crystal, stack, _i, _j, _len, _ref, _ref1;
      for (stack = _i = _ref = this.crystals.length - 2; _ref <= 0 ? _i <= 0 : _i >= 0; stack = _ref <= 0 ? ++_i : --_i) {
        _ref1 = this.crystals[stack];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          crystal = _ref1[_j];
          this.crystals[stack + 1].push(crystal);
        }
        this.crystals[stack] = [];
      }
      return this.render();
    };

    Crystals.prototype.onStackClick = function(e) {
      var crystal, energy;
      energy = parseInt($(e.currentTarget).attr('data-energy'));
      if (energy > 0 && this.crystals[energy].length > 0) {
        crystal = this.crystals[energy][this.crystals[energy].length - 1];
        return this.spendCrystal(crystal);
      }
    };

    Crystals.prototype.spendCrystal = function(crystal) {
      return console.log("Spending a crystal! " + crystal.energy);
    };

    Crystals.prototype.render = function(force) {
      var card, cardScale, count, crystal, i, r, scale, slot, stack, stacks, thisRender, unchanged, unscaledWidth, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2;
      if (force == null) {
        force = false;
      }
      unchanged = true;
      thisRender = [];
      for (i = _i = 0, _ref = this.crystals.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this["crystals" + i] = this.crystals[i].length;
        if (this.crystals[i].length !== this.lastRender[i]) {
          unchanged = false;
        }
        thisRender[i] = this.crystals[i].length;
      }
      if (unchanged && !force && 1 === 2) {
        return this;
      }
      $('.crystals-stack', this.div).unbind();
      unscaledWidth = 700;
      this.stackWidth = Math.floor(this.width / 6);
      scale = this.width / (unscaledWidth * 6);
      this.div.html(this.template(this));
      this.div.height(this.height).css({
        top: "" + this.top + "px"
      });
      stacks = $('.crystals-stack', this.div).css({
        width: "" + this.stackWidth + "px",
        height: "" + this.height + "px"
      }).bind('click touchstart', this.onStackClick);
      for (i = _j = 0, _ref1 = this.crystals.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        slot = $(".crystals-stack-" + i, this.div);
        slot.css({
          left: i * this.stackWidth + "px"
        });
        stack = $(".cards", slot);
        count = 0;
        _ref2 = this.crystals[i];
        for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
          crystal = _ref2[_k];
          x = this.stackWidth / 2 / scale - this.cardWidth * .5 + this.pseudoRandom((i * Math.PI * 1000) * count, -10, 10);
          x *= scale;
          y = this.cardHeight * .5 * this.height / this.stackWidth + count * 20 + this.pseudoRandom((i * Math.PI * 2000) * count, 0, 4);
          y *= scale;
          r = this.pseudoRandom((i * Math.PI * 3000) * count, -10, 10);
          card = $('<div>').append($(this.cardTemplate(crystal)));
          cardScale = scale * 1.4;
          card.css({
            "transform-origin": "50% 50%",
            transform: "translate3d(" + x + "px, " + y + "px, 0px) rotateZ(" + r + "deg) scale(" + cardScale + ")",
            top: 10 * count
          });
          stack.append(card);
          count++;
        }
      }
      this.lastRender = thisRender;
      return this;
    };

    Crystals.prototype.pseudoRandom = function(seed, min, max) {
      var r;
      r = seed * Math.PI * 1000000;
      r = r - Math.floor(r);
      return (max - min) * r + min;
    };

    return Crystals;

  })(Backbone.Model);

}).call(this);

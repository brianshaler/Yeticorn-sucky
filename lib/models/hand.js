// Generated by CoffeeScript 1.4.0
(function() {
  var Crystal, Crystals, Spell, Weapon, cardHeight, cardTemplate, cardWidth, template,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  template = require('views/templates/hand');

  cardTemplate = require('views/templates/card');

  Crystal = require('models/crystal_card');

  Weapon = require('models/weapon_card');

  Spell = require('models/spell_card');

  cardWidth = 142;

  cardHeight = 223;

  module.exports = Crystals = (function(_super) {

    __extends(Crystals, _super);

    function Crystals() {
      this.render = __bind(this.render, this);

      this.onCardClick = __bind(this.onCardClick, this);
      return Crystals.__super__.constructor.apply(this, arguments);
    }

    Crystals.prototype.template = template;

    Crystals.prototype.cardTemplate = cardTemplate;

    Crystals.prototype.cardWidth = cardWidth;

    Crystals.prototype.cardHeight = cardHeight;

    Crystals.prototype.defaults = {
      player: '',
      cards: [],
      cached: false,
      left: 0,
      right: 0,
      top: 0,
      width: 1,
      height: 1,
      isLandscape: true
    };

    Crystals.prototype.initialize = function() {
      var prop, val, _ref;
      this.div = $('<div>');
      this.width = 1;
      this.height = 1;
      _ref = this.attributes;
      for (prop in _ref) {
        val = _ref[prop];
        this[prop] = val;
      }
      this.cards.push(new Crystal());
      this.cards.push(new Crystal());
      this.cards.push(new Weapon());
      this.cards.push(new Spell());
      this.cards.push(new Crystal());
      this.cards.push(new Weapon());
      return this.cached = false;
    };

    Crystals.prototype.update = function(prop, val) {
      var props;
      if (typeof prop === 'object') {
        props = prop;
      } else {
        props = {};
        props[prop] = val;
      }
      for (prop in props) {
        val = props[prop];
        if ((prop != null) && this.attributes.hasOwnProperty(prop)) {
          this.attributes[prop] = val;
        }
        this[prop] = val;
      }
      this.cached = false;
      return this.render();
    };

    Crystals.prototype.onCardClick = function(e) {
      var card;
      card = $(e.currentTarget).data('card');
      return console.log("Clicked card in hand: " + card.type);
    };

    Crystals.prototype.render = function(force) {
      var card, cardScale, count, r, scale, x, y, _i, _j, _len, _len1, _ref, _ref1;
      if (force == null) {
        force = false;
      }
      if (this.cached && !force) {
        return this;
      }
      $('.playing-card', this.div).unbind();
      this.div.html(this.template(this));
      this.div.width(this.width).height(this.height).css({
        left: "" + this.left + "px"
      });
      _ref = this.cards;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        if (!card.div) {
          card.div = $(this.cardTemplate(card));
        }
        card.div.data('card', card);
        $('.cards', this.div).append(card.div);
      }
      $('.playing-card', this.div).bind('click touchstart', this.onCardClick);
      scale = this.isLandscape ? this.width / this.cardWidth * .7 : this.height / this.cardHeight * .8;
      count = 0;
      _ref1 = this.cards;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        card = _ref1[_j];
        x = !this.isLandscape ? this.width / 2 / scale + (count - this.cards.length * .5) * this.cardWidth * .7 : this.width / 2 / scale;
        x += this.pseudoRandom(count * Math.PI * 1000, 0, 10);
        y = this.isLandscape ? this.height / 2 / scale + (1 + count - this.cards.length * .5) * this.cardWidth * .5 : this.height / 2 / scale;
        y += this.pseudoRandom(count * Math.PI * 2000, 0, 10);
        r = this.pseudoRandom(count * Math.PI * 3000, -10, 10);
        cardScale = scale * 1;
        card.div.css({
          "transform-origin": "50% 50%",
          transform: "translate3d(-" + (this.cardWidth / 2) + "px, -" + (this.cardHeight / 2) + ("px, 0px) scale(" + cardScale + ") translate3d(" + x + "px, " + y + "px, 0px) rotateZ(" + r + "deg)")
        });
        count++;
      }
      return this.cached = true;
    };

    Crystals.prototype.pseudoRandom = function(seed, min, max) {
      var r;
      r = seed * Math.PI * 1000000;
      r = r - Math.floor(r);
      return (max - min) * r + min;
    };

    return Crystals;

  })(Backbone.Model);

}).call(this);
